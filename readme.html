**P00 - Domain-Specific Language**

Author
=============

<!-- Note: wrapping table in div.noheader will hide the table's header -->
<!-- Note: wrapping table in div.firstcol will style the first column different from other columns -->
<div class="noheader firstcol">
                  |             
------------------|-------------
name              | Dylan Fridman
computer + OS     | MacBook Air, macOS Sonoma
partner           | Sebastian Frazier, Javier Rodillas, Walker Ball
</div>

Domain
=================

The domain of our problem is climbing systems, i.e.,
the set of tools, techniques, and practices used to stay (relatively) safe while climbing.
An expert in our domain would be a rock climbing guide:
somebody who can solve tough situations that arise while climbing.
A regular user of our domain would be a climber who wants to learn new techniques
or improve their climbing systems knowledge in an interactive way.

Problem
================

<!--
The problem that we want to solve is to write a language that can take
a series of actions in a climbing scenario and output the resulting state.

The problem of our project focuses on creating a language that can parse a climbing scenario given a description of events in the form of 
'objects' and 'actions' and output a described result state of the scenario. Our aim is to generate singular descrpitions of end-states
for climbing scenarios after parsing the input.
-->

The problem of our project focuses on creating a language that can parse a climbing scenario given a
description of a starting scenario and the series actions/events that took place. This would allow us to

1. Find solutions to technical climbing problems.
2. Generate diagrams of climbing systems that could be used for educational purposes.
3. Verify that a given solution for a problem makes sense which could also be used for educational purposes.

<!--
The problem of our project will deal with the creation of a program that can parse a climbing 'scenario' and output a 'solution' in the form of
an order set of actions that effectively deal with the scenario. Our aim is to generate singular solutions given generated scenarios which we
will write and determine if a user free-response input matches the computed solution or not. 

An example 'scenario' in non-code terms that we may use is how to clean a 'sport' climbing route on rappel.
For reference: A 'sport' climbing route is a route with permanent bolted anchors and protection.

Our scenario may resemble the following: if a climber is at the top of a sport climbing route and desires to clean the route by rapelling with a 
standard rapel kit, how should they go about this action?
-->

A verbose version of a possible input, representing the series of actions somebody can take to clean a route on rappel,  could look like the following

1. Clip into the anchor with a PAS
2. Add a backup
3. Hitch the 'sharp' end of the rope to something to prevent it from falling
4. Untie from the rope
5. Pull the rope through both rings of the anchor until reaching the midpoint
6. Tie knots in both ends of the rope
7. Throw both ends of the rope down
8. Check for snags
9. Pull up slack from the rope
10. Attach an extended ATC device to the rope.
11. Attach a 'friction hitch' to the rope
12. Attach the hitch to the climber via a locking carabiner
13. Pull in slack such until the climber weights the system
14. Detach PAS and backup
15. Slowly and carefully lower oneself down
16. Pause at each 'quickdraw' and detach it from the wall
17. After reaching the ground, detach oneself from the rope by undoing the earlier systems
18. Untie the knots in both ends of the rope
19. Pull the rope down from one side until it falls.

Then, the program would output the final state of the scenario,
which would be the climber at the bottom of the route with the rope on the ground but
showing a list of tips/things to improve which would include attaching the friction hitch
used for the third hand before clipping the ATC.

Also, when the input to the program requests it, the program would output a diagram of the final state or a digram per action taken.

Problem: cleaning a route on rappel
--------------------------------

~~~~
def climb_route(Climber climber, Belayer belayer, Route route):
  tie
    knot: FIGURE_EIGHT
    climber: climber
    target: climber.harness.hardpoints  
  
  check
    climber: climber
    belayer: belayer
  
  go_up
    climber: climber
    route: route

  tie
    knot: CLOVE
    climber: climber
    target: route.anchor

def problem:
  problem.description = "Clean the route on rappel" // Hard-written by programmer
  

  # Definitions
  Climber basty
  Belayer dylan
  Route lulu
  lulu.set_anchor
    QUAD

  # Context Actions
  climb_route
    climber: basty
    belayer: dylan
    route: lulu

problem
~~~~

**Input**

`verbose`

**Output**

`The climber "basty" is at the top of "Lulu", "cloved" into a "quad" anchor.`

Functionality
================

First of all, the type of output depends on the input type.
The input type can be either `verbose`, `code`, or `diagram`.
If it's verbose, the output is a human-readable explanation of
the resulting scenario. If it's code, the output is more easily
read by a computer than by a human. If it's diagram, the output is
a diagram that depicts the final scenario.
The output will be determined by processing each "primitive" action one by one.
By primitive action we mean actions that are not composed of other actions.


Grammar
================

~~~~
grammar Lang;

// Main
file        : block EOF;
block       : statement* ;
statement   : declaration | func_def | func_call | assignment ;

// Functions
func_def            : 'define' ID '(' def_param_list? ')' '{' block '}' ;

func_call           : ID '(' mixed_param_list? ')' ;

mixed_param_list    : named_param_list
                    | param_list
                    | param_list ',' named_param_list
                    ;

named_param_list    : attribute_pair
                    | attribute_pair ',' named_param_list
                    ;

def_param_list      : ID
                    | ID ',' def_param_list
                    ;

param_list          : expr
                    | expr ',' param_list
                    ;

// Assignment
assignment      : id '=' expr;
declaration     : CLASS ID? ('{' attribute_list '}')? ;
attribute_list  : attribute_pair* ;
attribute_pair  : attribute ':' expr;

// Expressions and identifiers
expr        : id
            | declaration
            | (declaration '.' attribute)
            | list
            | tuple
            | grade
            | constants
            | math_expr
            | func_call
            | LENGTH
            | STRING
            | ANGLE
            | CAM_SIZE
            ;

list        : '[' expr_seq ']';
tuple       : '(' expr_seq ')';

expr_seq    : expr
            | expr ',' expr_seq
            |
            ;

attribute   : ID;

id          : ID
            | ID '.' id
            ;

grade       : YDS_GRADE | FRENCH_GRADE ;

constants   : ROUTE_STYLES
            | ROPE_RATINGS
            | ANCHOR_SYSTEMS
            | DRAW_TYPES
            | CARABINER_TYPES
            | knots
            ;

knots       : PROPER_KNOTS
            | BENDS
            | HITCHES
            | OTHER
            ;

// Handling of mathematical expressions
math_expr   : term terms;

terms       : '+' term terms
            | '-' term terms
            |
            ;

term        : factor factors;

factors     : '*' factor factors
            | '/' factor factors
            | 'MOD' factor factors
            |
            ;

factor      : '(' math_expr ')'
            | id | LENGTH
            | NUM
            ;

// Terminals
CLASS           : 'Rope'
                | 'Route'
                | 'Attachment'
                | 'Climber'
                | 'Knot'
                | 'Carabiner'
                | 'GriGri'
                | 'Vector'
                | 'ProPossibility'
                | 'Protection'
                | 'Bolt'
                | 'RapRing'
                | 'Cam'
                | 'Draw'
                | 'DyneemaSling'
                | 'AnchorSystem'
                ;

ROUTE_STYLES    : 'MIXED' // Both trad and sport, no ice stuff for now
                | 'TRAD'
                | 'SPORT'
                ;

ROPE_RATINGS    : 'SINGLE'
                | 'TAG_LINE'
                | 'HALF'
                | 'TWIN'
                | 'DOUBLE' // Both half and twin?
                ;

ANCHOR_SYSTEMS  : 'QUAD'
                | 'SLIDING_X'
                | 'W_ANCHOR' // Is there a better name?
                ;

DRAW_TYPES      : 'SPORT_DRAW'
                | 'ALPINE_DRAW'
                ;

CARABINER_TYPES : 'LOCKING'
                | 'NON-LOCKING'
                ;

PROPER_KNOTS    : 'BARREL'
                | 'OVERHAND_ON_A_BIGHT'
                | 'FIGURE_EIGHT_ON_A_BIGHT'
                | 'FIGURE_EIGHT_FOLLOW_THROUGH'
                | 'BUTTERFLY'
                | 'MUNTER_MULE_OVERHAND'
                ;

BENDS           : 'DOUBLE_FISHERMAN'
                | 'TRIPLE_FISHERMAN'
                | 'FLAT_OVERHAND'
                | 'FLEMISH'
                ;

HITCHES         : 'CLOVE'
                | 'PRUSIK'
                | 'AUTOBLOCK'
                | 'KLEMHEIST'
                | 'MUNTER'
                ;

OTHER           : 'TANGLE'
                ;

STRING          : '\'' .*? '\'' ;
LENGTH          : [0-9]+ ('cm' | 'm' | 'ft' | 'in') ;
ID              : [a-z] ([a-z] | [0-9] | '_')* ;
YDS_GRADE       : ('5.' [0-9] ('+' | '-')?) | ('5.1' [0-5] ('+' | '-' | [a-d])?) | '4th' | '3rd' ;
FRENCH_GRADE    : 'FRENCH' ([123] | [45][abc] | [678][abc] ('+')? | '9'[ab] ('+')? | '9c');
ANGLE           : '-'? [0-9]+ 'deg' ;
WEIGHT          : [0-9]+ ('g' | 'kg') ;
CAM_SIZE        : '.'[1-5] | '.75' | '#'[1-8] ;
NUM : [0-9]+;

// Whitespace and comments
WS              : (' ' | '\t' | '\n' | ';') -> skip ;
COMMENT         : '//' ~[\r\n]* -> skip ;
BLOCKCOMMENT    : '/*' .*? '*/' -> skip ;
~~~~

Examples
================

Setting up the scenario to go climbing
--------------------------------

~~~~
define lulu_climbing_setup() {
  // Protection { type: Bolt } <-- Example of anonymous object

  Protection p1 {
    type: [Cam { size: #2 }]
  }

  Protection p2 {
    type: [Bolt]
  }

  Vector v1 {
    angle: 40deg
    length: 5m
  }

  Vector v2 {
    angle: -30deg
    length: 3m
  }

  Vector v3 {
    angle: 0deg
    length: 5m
  }

  Protection p3 {
    type: [
      Bolt {
        with: RapRing
      },
      Bolt {
        with: RapRing
      }
    ]
  }

  Route lulu {
    length: 100ft // Shouldn't this be computed from protection?
    grade: 5.12b
    protection: [(p1, v1), (p2, v2), (p3, v3)]
    type: MIXED
  }

  lulu.name = 'Flesh for Lulu' // example of modifying attributes

  Climber alice {
    gear: [
      Cam { size: #2 },
      Draw { type: ALPINE_DRAW },
      Draw,
      Draw,
      GriGri,
      DyneemaSling { length: 240cm },
      Carabiner { type: LOCKING },
      Carabiner { type: LOCKING },
      Carabiner { type: LOCKING }
    ]
  }

  GriGri bobs_grigri

  Climber bob {
    gear: [bobs_grigri]
  }

  Rope rope {
    length: 70m
    rated: SINGLE
  }

  Knot alice_figure8 {
    type: FIGURE_EIGHT_FOLLOW_THROUGH
    with: rope.first_end
    on: alice.harness.hardpoints
  }

  Knot barrel {
    type: BARREL
    with: rope.second_end
  }

  Carabiner belay_locker {
    type: LOCKING
    clipped_to: [bob.harness.belay_loop, bobs_grigri]
  }

  Attachment grigri_rope {
    device: bobs_grigri
    to: rope
    active_side: rope.first_end
    distance_to_end: 4m
  }

  // For now, let's assume all climbers have harness, helmet, shoes?
}

lulu_climbing_setup()
~~~~

A follower is climbing up 
--------------------------------

~~~~
define problem() {
  AnchorSystem quad {
    type: QUAD
    using: [Carabiner c1 { type: LOCKING }, Carabiner c2 { type: LOCKING }]
  }

  Route duet {
    name: 'Duet'
    length: 100ft
    grade: 5.7
    anchor: [
      Bolt anchor_bolt1 { with: RapRing },
      Bolt anchor_bolt2 { with: RapRing }
    ]
  }

  Attachment anchor_carabiner1 {
    device: c1
    to: anchor_bolt1.with
  }

  Attachment anchor_carabiner2 {
    device: c2
    to: anchor_bolt2.with
  }

  Climber alice {
    gear: [
      GriGri alice_grigri,
      DyneemaSling { length: 240cm },
      Carabiner c1 { type: LOCKING },
      Carabiner c2 { type: LOCKING },
      Carabiner c3 { type: LOCKING },
      Carabiner c4 { type: LOCKING },
      Carabiner c5 { type: LOCKING }
    ]
  }

  Climber bob {
    gear: [GriGri]
  }

  Rope rope {
    length: 70m
    rated: SINGLE
  }

  Carabiner alice_clove_carabiner {
    type: LOCKING
    clipped_to: [quad.masterpoint]
  }

  Knot alice_clove {
    type: CLOVE
    with: r1.at // Can attributes be methods??? I wanna say at 2m
    on: alice_clove_carabiner
  }

  Knot alice_figure8 {
    type: FIGURE_EIGHT_FOLLOW_THROUGH
    with: r1.first_end
    on: alice.harness.hardpoints
  }

  Knot bob_figure8 {
    type: FIGURE_EIGHT_FOLLOW_THROUGH
    with: r1.second_end
    on: bob.harness.hardpoints
  }

  Attachment grigri_rope {
    device: alice_grigri
    to: rope.at // 60m
    active_side: rope.second_end
  }

  Carabiner belay_locker {
    type: LOCKING
  }

  Attachment {
    device: alice_grigri
    to: belay_locker
  }

  Attachment {
    device: belay_locker
    to: quad.masterpoint
  }
}

// Set up the scenario of the problem
problem()

// Solution to the problem
// ...
~~~~

A rope gets stuck after lowering back to the ground
--------------------------------

~~~~
define rope_stuck {

  rope_stuck.name = 'Venus on a Halfshell' // example of modifying attributes

  Protection p1 {type: [Bolt]}

  Protection p2 {type: [Bolt]}

  Protection p3 {type: [Bolt]}

  Protection p4 {type: [Bolt]}

  Vector v1 {
    angle: 0deg
    length: 5m
  }
  Vector v2 {
    angle: 0deg
    length: 5m
  }
  Vector v3 {
    angle: 0deg
    length: 5m
  }
  Vector v4 {
    angle: 0deg
    length: 5m
  }
  Vector v5 {
    angle: 0deg
    length: 5m
}
  Vector v6 {
    angle: 15deg
    length: 3m
}
  Protection p5 {type: [Bolt { with: RapRing }, Bolt { with: RapRing }]}

  Route venus {
    length: sum([v1, v2, v3, v4, v5])
    grade: 5.12c
    protection: [(p1, v1), (p2, v2), (p3, v3), (p4, v4), (p5, v5)]
    type: MIXED
    status: completed
  }

  Climber sebastian {
    gear: [
      Draw,
      Draw,
      Draw,
      Draw,
      Draw,
      Draw
      carabiner { type: LOCKING }
    ]
    location: ground
  }
  GriGri dylan_grigri // Just a declaration

  Climber dylan {
    gear: [
        dylan_grigri,
        dylan_locker]
  }
  Rope rope {
    length: 60m
    rated: SINGLE
  }
  Knot anchor_block {
    type: TANGLE
    with: rope.middle
    on: constriction
  }
  Protection constriction {
    type: crack
    size: .3
    location: (p3, v6)
  }
  Knot sebastian_figure8 {
    type: FIGURE_EIGHT_FOLLOW_THROUGH
    with: rope.first_end
    on: sebastian.harness.hardpoints
  }
  Carabiner dylan_locker {
    type: LOCKING
    clipped_to: [dylan.harness.belay_loop, dylan_grigri]
  }
  Attachment grigri_rope {
    device: dylan_grigri
    to: rope
    active_side: rope.first_end
    distance_to_end: rope.length - 2 * venus.length
  }
  // Let's assume all climbers have harness, helmet, shoes?
}

stuck_rope()
~~~~

Examples
================

Good 1
--------------------------------

~~~~
Route {
  name: 'Anonymous'
  fakeAttribute: fakeIdentifier
}
~~~~

Good 2
--------------------------------

~~~~
// Nested functions!

define fn() {
    define other_fn() {
        Route r
    }
}
~~~~

Good 3
--------------------------------

~~~~
// Object assignment

my_var = 3

my_var = Route {
    name: 'Meltdown'
}
~~~~

Good 4
--------------------------------

~~~~
w = FRENCH 6a

x = 5.12b

y = 5m

z = SINGLE

x.y.z = 3

// This is syntactically valid despite being semantic non-sense
// (considering that x is a climbing grade)
~~~~

Good 5
--------------------------------

~~~~
Vector v1 {
  angle: 5m
  length: 40deg
}

// Syntactically allowed
~~~~

Bad 1
--------------------------------

~~~~
FakeClass {
  test: 'test';
}
~~~~

Bad 2
--------------------------------

~~~~
Route {
  name: 'Anonymous'
  fake_attribute: conventionsMatterInThisWorld
}
~~~~

Bad 3
--------------------------------

~~~~
y = 4m + 2m
x = 30deg + 4m
~~~~

Bad 4
--------------------------------

~~~~
x = [[[]], (())]

y = []][[] // non-sense
~~~~

Bad 5
--------------------------------

~~~~
too_hard = 5.16a
same_thing = FRENCH 9c+
too_easy = 2nd
~~~~

<!--   Feel free to modify the following to fit a theme of your choosing   -->
<link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet"> <!-- a sans-serif font -->
<style>  /* A TAYLOR-INSPIRED THEME */
    body {font-family:'Open Sans',sans-serif;}
    .md a:link, .md a:visited {color:hsl(252,23.0%,44.3%); font-family:'Open Sans',sans-serif;}
    .md table.table th {background-color:hsl(252,23.0%,44.3%);}
    .md .noheader th {display:none;}
    .md .firstcol td:first-child {white-space:pre;color:white;vertical-align:top;font-weight:bold;border-color:black;background:hsl(252,23.0%,54.3%);}
    .md .firstcol tr:nth-child(even) td:first-child {background:hsl(252,23.0%,44.3%);}
</style>


<!-- ****************************** -->
<!--    Leave the content below     -->
<!-- ****************************** -->

<!-- The script and style below are added for clarity and to workaround a bug -->
<script>
    // this is a hack to workaround a bug in Markdeep+Mathjax, where
    // `$`` is automatically converted to `\(`` and `\)`` too soon.
    // the following code will replace the innerHTML of all elements
    // with class "dollar" with a dollar sign.
    setTimeout(function() {
        var dollars = document.getElementsByClassName('dollar');
        for(var i = 0; i < dollars.length; i++) {
            dollars[i].innerHTML = '&#' + '36;'; // split to prevent conversion to $
        }
    }, 1000);
</script>
<style>
    /* adding some styling to <code> tags (but not <pre><code> coding blocks!) */
    :not(pre) > code {
        background-color: rgba(0,0,0,0.05);
        outline: 1px solid rgba(0,0,0,0.15);
        margin-left: 0.25em;
        margin-right: 0.25em;
    }
    /* fixes table of contents of medium-length document from looking weird if admonitions are behind */
    .md div.mediumTOC { background: white; }
    .md div.admonition { position: initial !important; }
</style>

<!--   Leave the following Markdeep formatting code, as this will format your text above to look nice in a wed browser   -->

<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js"></script><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>